--!strict

--[[
Script is coded by MiniSardine
(sinthel_ on discord and applying with the account lSinthel)
This is being created for a hiddendev application!
Expect this to be open-source on github shortly!

A Wrapper with some added functionality for the MarketplaceService,
Designed to be used with gui's so they can quickly display gamepasses with information!

]]--

local mss = game:GetService("MarketplaceService")

local marketLib = {
	['Passes'] = {},
	['Products'] = {}
}

--a gamepass data type
export type gamepass = {
	Name: string,
	Description: string,
	Id: number,
	Price: number,
	Function: any
}

export type devProduct = {
	Name: string,
	Description: string,
	Id: number,
	Price: number,
	Function: any
}

--a function to find and return a gamepass with a given id
local function find_gamepass(id: number)
	for _,v in pairs(marketLib.Passes) do
		if v.Id == id then
			return v
		end
	end
	return nil
end

local function find_product(id: number)
	for _,v in pairs(marketLib.Products) do
		if v.Id == id then
			return v
		end
	end
	return nil
end


--runs on a gamepass purchases, and if there is a pass with said Id, it will call the function attached
mss.PromptGamePassPurchaseFinished:Connect(function(plr, passid, success)
	if success == true then
		local passexists = find_gamepass(passid)
		if passexists then
			passexists.Function()
		end
	end
end)

mss.PromptProductPurchaseFinished:Connect(function(plr, passid, success)
	if success == true then
		local productxists = find_product(passid)
		if productxists then
			productxists.Function()
		end
	end
end)

--the main cycle for the module
local function begin_cycle()
	local i = 1
	game["Run Service"].Heartbeat:Connect(function()
		i += 1
		--a loop being called prior to every frame, that is updating the player's passFolder with the passes from the passes table and inserting passes that aren't found
		for i, player in game.Players:GetPlayers() do
			
			local passFolder = player:WaitForChild("passFolder")
			
			for i, attr in marketLib['Passes'] do
				
				local found = passFolder:FindFirstChild(i)
				
				if not found then
					
					local fold = Instance.new("Folder")
					fold.Parent = passFolder
					fold.Name = i
					
					for _, thing in pairs(attr) do
						
						local thingtype = typeof(thing)
						
						if thingtype == "string" then
							
							local newval = Instance.new("StringValue")
							newval.Name = _
							newval.Parent = fold
							newval.Value = thing
							
						elseif thingtype == "number" then
							
							local newval = Instance.new("NumberValue")
							newval.Name = _
							newval.Parent = fold
							newval.Value = thing
							
						end
					end
				end
			end
		end
		--[[if i >= 60 then
			i = 0
			datastore:storeData(game.PlaceId.."-passes", marketLib['Passes'])
		end
		print(marketLib['Passes'])]]--
	end)
end


--lists a new gamepass and begins the cycle
function marketLib.ListGamepass(data: gamepass)
	assert(typeof(data) == "table", "[MarketLibrary] - Attempt to upload a non-gamepass object")
	assert(typeof(data.Function) == "function", "[MarketLibrary] - Attempt to connect a non-function to a gamepass")
	
	begin_cycle()
	
	marketLib['Passes'][data.Name] = data
	
	return true
end

function marketLib.ListProduct(data: devProduct)
	assert(typeof(data) == "table", "[MarketLibrary] - Attempt to upload a non-dev-product object")
	assert(typeof(data.Function) == "function", "[MarketLibrary] - Attempt to connect a non-function to a dev-product")

	begin_cycle()

	marketLib['Products'][data.Name] = data

	return true
end

--unlists a gamepass and removes the gamepass folder from every player's passFolder
function marketLib.UnlistGamepass(id: number)
	assert(typeof(id) == "number", "[MarketLibrary] - Attempt to use a non-integer for a gamepass ID")
	
	local found = find_gamepass(id)
	
	if found then
		
		table.remove(marketLib['Passes'],table.find(marketLib['Passes'],marketLib['Passes'][found.Name]))
		
		for i, plr in pairs(game.Players:GetPlayers()) do
			
			if plr:WaitForChild("passFolder"):FindFirstChild(i) then
				
				plr:WaitForChild("passFolder"):FindFirstChild(i):Destroy()
				
			end
		end
		return true
		
	else
		return false
	end
end

function marketLib.UnlistProduct(id: number)
	assert(typeof(id) == "number", "[MarketLibrary] - Attempt to use a non-integer for a dev-product ID")

	local found = find_product(id)

	if found then

		table.remove(marketLib['Products'],table.find(marketLib['Products'],marketLib['Products'][found.Name]))

		for i, plr in pairs(game.Players:GetPlayers()) do

			if plr:WaitForChild("productFolder"):FindFirstChild(i) then

				plr:WaitForChild("productFolder"):FindFirstChild(i):Destroy()

			end
		end
		return true

	else
		return false
	end
end

--checks if a user owns a pass with the given Id, and returns true or false accordingly
function marketLib.UserOwnsPass(user: Player, id: number)
	assert(typeof(id) == "number", "[MarketLibrary] - Attempt to use a non-integer for a gamepass ID")
	assert(typeof(user) == "Player", "[MarketLibrary] - Attempt to check a non-player for a gamepass")
	print(typeof(user))
	
	local found = mss:UserOwnsGamePassAsync(user.UserId,id)
	if found then
		return true
	else
		return false
	end
end

--prompts the given user the opportunity to purchase a gamepass or product with the given id
function marketLib.PromptPurchase(player: Player, id: number)
	assert(typeof(id) == "number", "[MarketLibrary] - Attempt to use a non-integer for a gamepass ID")
	assert(typeof(player) == "Player", "[MarketLibrary] - Attempt to check a non-player for a gamepass")
	
	mss:PromptPurchase(player,id)
end

--inserts the passFolder into each player who joins
game.Players.PlayerAdded:Connect(function(plr)
	local passFolder = Instance.new("Folder")
	passFolder.Parent = plr
	passFolder.Name = "passFolder"
	
	local productFolder = Instance.new("Folder")
	productFolder.Parent = plr
	productFolder.Name = "productFolder"
	
	for i, v in marketLib['Passes'] do
		local fold = Instance.new("Folder")
		fold.Parent = passFolder
		fold.Name = i
		for _, thing in pairs(v) do
			local thingtype = typeof(thing)

			if thingtype == "string" then

				local newval = Instance.new("StringValue")
				newval.Name = _
				newval.Parent = fold
				newval.Value = thing

			elseif thingtype == "number" then

				local newval = Instance.new("NumberValue")
				newval.Name = _
				newval.Parent = fold
				newval.Value = thing

			end
		end
	end
	for i, v in marketLib['Products'] do
		local fold = Instance.new("Folder")
		fold.Parent = productFolder
		fold.Name = i
		for _, thing in pairs(v) do
			local thingtype = typeof(thing)

			if thingtype == "string" then

				local newval = Instance.new("StringValue")
				newval.Name = _
				newval.Parent = fold
				newval.Value = thing

			elseif thingtype == "number" then

				local newval = Instance.new("NumberValue")
				newval.Name = _
				newval.Parent = fold
				newval.Value = thing

			end
		end
	end
end)

return marketLib
